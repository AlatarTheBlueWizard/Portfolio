<!DOCTYPE html>
<html>

<head>
    <title>Notes W04</title>
    <style>
        body {
            background-color: lightgrey;
        }
        
        button {
            background-color: lightgreen;
            border: 2px solid black;
        }
    </style>
</head>

<body>
    <a href="../../index.html"><button>Click to go to home page</button></a>
    <a href="../W04.html"><button>Click to go to week 4 page</button></a>
    <h1>Forms</h1>
    <ul>
        <li>Forms are the primary method used for entering data into a browser</li>
        <li>Forms have a variety of controls that are used for entering different types of information</li>
        <li>HTML5 has a large number of new input types that are beginning to be implemented in modern browsers</li>
        <li>document.forms will return an HTML collection of all the forms on a page</li>
        <li>form.elements will return an HTML collection of all the elements contained within a form</li>
        <li>Forms have focus , blur , and change events that fire as a user interacts with the form</li>
        <li>Forms also have a submit event that can be used to intercept a form before it’s been submitted</li>
        <li>The information entered into a form can be read or updated using the value property of the form controls</li>
    </ul>
    <h1>Object Oriented Programming</h1>
    <ul>
        <li>Object-oriented programming (OOP) is a way of programming that uses objects that encapsulate their own properties and methods</li>
        <li>The main concepts of OOP are encapsulation, polymorphism and inheritance</li>
        <li>Constructor functions can be used to create instances of objects</li>
        <li>ES6 introduced class declarations that use the class keyword. These can be used in place of constructor functions</li>
        <li>Inside a constructor function or class declaration, the keyword this refers to the object returned by the function</li>
        <li>All instances of a class or constructor function inherit all the properties and methods of its prototype</li>
        <li>The prototype is live, so new properties and methods can be added to existing instances</li>
        <li>The prototype chain is used to find an available method. If an object lacks a method, JavaScript will 
            check whether its prototype has the method. If not, it will check that function’s prototype until it 
            finds the method or reaches the Object constructor function</li>
        <li>Private properties and methods can be created by defining variables using const and defining a function 
            inside a constructor function. These can be made public using getter and setter functions</li>
        <li>Monkey-patching is the process of adding methods to built-in objects by augmenting their prototypes. This 
            should be done with caution as it can cause unexpected behavior in the way built-in objects work</li>
        <li>A mixin method can be used to add properties and methods from other objects without creating an inheritance chain</li>
        <li>Methods can be chained together and called in sequence if they return a reference to this</li>
        <li>Polymorphism allows objects to override shared methods with a more specific implementation</li>
        <li>The value of this is not retained inside nested functions, which can cause errors. This can be worked around 
            by using that = this , using the bind(this) method and using arrow functions</li>
        <li>Methods can be borrowed from other objects</li>
        <li>Composition over inheritance is a design pattern where objects are composed from 'building-block' objects, 
            rather than inheriting all their properties and methods from a parent class</li>
    </ul>
    <h1>Modular Javascript</h1>
    <ul>
        <li>A module is a self-contained piece of code that provides functions and methods that can then be used in other files and by other modules</li>
        <li>The code in a module should have a single purpose, and group together functions with distinct functionality</li>
        <li>Keeping code modular helps to make it more loosely coupled and interchangeable, meaning you can easily swap one module for another without affecting other parts of a project</li>
        <li>Modules also allow a public API to be exposed, while keeping the implementation hidden away inside the module</li>
        <li>The coupling of code refers to how dependent certain elements or modules of code are on each other</li>
        <li>It is considered good design to keep code as loosely coupled as possible as this allows for the most flexibility in 
            developing systems of code, as different modules can be used independently and in a variety of different applications, 
            rather than being restricted to a single use-case</li>
    </ul>
</body>

</html>